(load-file "common.edn")

(defchain upload
  ;; ; add charlie as auth key
  ;; "//Charlie" (ECDSA.PublicKey true) >= .payload2
  ;; (ToHex) (Log "charlie-key")
  ;; [fragments-index add-upload-auth-index .payload2] (Do make-calldata) = .call1
  ;; [sudo-index sudo-call .call1] (Do make-calldata) = .sudo-call1
  ;; ["//Alice" .sudo-call1 0] (Do send-signed-extrinsic) (Log "result1")

  ; add test asset
  1 (Do make-test-asset) = .test-asset
  [.test-asset 0 0] (Do test-upload-compressing)
  (| (Take 0) = .frag-cid-str)
  (| (Take 1) = .frag-hash)

  {"id" 1 "jsonrpc" "2.0" "method" "system_localListenAddresses" "params" []} (ToJson) (Http.Post rpc-server)
  (FromJson) (ExpectTable) (Take "result") (ExpectStringSeq) (Log)
  (ForEach
   (->
    (Log "connecting")
    = .p2p-address
    "swarm" >> .ipfs-args
    "connect" >> .ipfs-args
    .p2p-address >> .ipfs-args
    (Maybe (-> "" (Process.Run "ipfs" .ipfs-args)))))

  "repo" >> .ipfs-args-gc
  "gc" >> .ipfs-args-gc
  (Maybe (-> "" (Process.Run "ipfs" .ipfs-args-gc) nil))

  ; not ideal but we need to wait transaction is done and CI can be slow
  (Pause 5.0)

  "block" >> .ipfs-args-block
  "get" >> .ipfs-args-block
  .frag-cid-str >> .ipfs-args-block
  "" (Process.Run "ipfs" .ipfs-args-block) (StringToBytes)
  (Brotli.Decompress)
  (Is .test-asset) (Log) (Assert.Is true)

  "//Bob" (Sr25519.PublicKey) (ToHex) (Log "Bobs") = .bob-hex-key
  {"id" 1 "jsonrpc" "2.0" "method" "author_insertKey" "params" ["frag" "//Bob" .bob-hex-key]} 
  (ToJson) (Http.Post rpc-server) (Log)

  (Pause 10.0)

  ; now detach it
  [.frag-hash 1] (Do test-detach)
  ;
  )

(schedule root wait-port)
(if (run root 0.1) nil (throw "wait-port failed"))

(schedule root upload)
(if (run root 0.1) nil (throw "upload failed"))